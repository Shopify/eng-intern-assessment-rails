Article.delete_all

Article.create([
  { title: "Sidekick's Improved Streaming Experience", content: "In the realm of Large Language Model (LLM) chatbots, two of the most persistent user experience disruptions relate to streaming of responses:\n\nMarkdown rendering jank: Syntax fragments being rendered as raw text until they form a complete Markdown element. This results in a jarring visual experience.
  Response delay: The long time it takes to formulate a response by making multiple LLM roundtrips while consulting external data sources. This results in the user waiting for an answer while staring at a spinner.\n\nHere's a dramatic demonstration of both problems at the same time:Before smart order routing, the only customization available for order routing was allowing merchants to set a prioritized list of locations to route orders to. By default, our algorithm would always try to prioritize shipping all the items within a single order from one location where possible and if multiple locations fit this criteria, then it would use the prioritized list of locations to break this tie.\n\nOur goal with smart order routing was to make order routing more flexible for our merchants by allowing them to customize the order routing process based on their unique business setup, while making it as easy as possible to do natively within their admin. If routing orders were akin to making a coffee, it was like we upgraded merchants from a simple drip machine with the choice of decaf or regular, to a high-end espresso machine and their choice of any milks and syrups they wanted. In this situation, our ingredients were referred to as “routing rules” and our coffee machine represents our servers that the routing rules would run on.\n\nA routing rule is a function that determines how we rank all possible locations, given a certain parameter, to determine the best location for an order to be routed to. We formalized some of the questions we asked earlier as the default routing rules that we would build. For example, the question “Can I ship this from a warehouse in the buyer's country? ” became the routing rule to stay within the destination market. If a merchant added a routing rule for proximity to the buyer, all eligible locations would be ranked accordingly, with the closest location ranked best, and the farthest ranked worst. A merchant could combine any of these rules in any order they want to get the optimal location assigned to an order. If a merchant decided shipping from locations closest to buyers was the most important factor, followed by a prioritized list of locations, they could set this up in that order with the Order Routing settings in their admin.\n\nWhile this was a great starting point, think of this scenario: what if we only provide oat and soy milk, but our merchant wants to use their special homemade almond milk? Well, we shouldn't stop them (within reasonable parameters of course). We knew that the ultimate goal of this project was extensibility for our merchants. We wanted them to be able to further customize how they wanted to route their orders by bringing in their own routing rules, but we needed to design the new order routing process in a way that merchants could use our routing rules and bring their own rules. In comes Shopify Functions. With Shopify Functions, developers could create their own logic compiled into a WebAssembly (Wasm) module, and plug it into our servers.", author: "Ebun Segun", date: Date.new(2023, 4, 4) },
  { title: "Building a ShopifyQL Code Editor", content: "In October 2022, Shopify released ShopifyQL Notebooks, a first-party app that lets merchants analyze their shop data to make better decisions. It puts the power of ShopifyQL into merchants' hands with a guided code editing experience. In order to provide a first-class editing experience, we turned to CodeMirror, a code editor framework built for the web. Out of the box, CodeMirror didn't have support for ShopifyQL-here's how we built it.\n\nShopifyQL is an accessible, commerce-focused querying language used on both the client and server. The language is defined by an ANTLR grammar and is used to generate code for multiple targets (currently, Go and Typescript). This lets us share the same grammar definition between both the client and server despite differences in runtime language. As an added benefit, we have types written in Protobuf so that types can be shared between targets as well.\n\nAll the ShopifyQL language features on the front end are encapsulated into a typescript language server, which is built on top of the ANTLR typescript target. It conforms to Microsoft's language server protocol (LSP) in order to keep a clear separation of concerns between the language server and a code editor. LSP defines the shape of common language features like tokenization, parsing, completion, hover tooltips, and linting.\n\nCodeMirror has its own grammar & parser engine called Lezer. Lezer is used within CodeMirror to generate parse trees, and those trees power many of the editor features. Lezer has support for common languages, but no Lezer grammar exists for ShopifyQL. Lezer also doesn't conform to LSP. Because ShopifyQL's grammar and language server had already been written in ANTLR, it didn't make sense to rewrite what we had as a Lezer grammar. Instead, we decided to create an adapter that would conform to LSP and integrate with Lezer. This allowed us to pass a ShopifyQL query to the language server, adapt the response, and return a Lezer parse tree.\n\nNotice that only the start character for SHOW changed! It changed from 0 to 5 after adding five spaces before the SHOW keyword. However, product_title's values remain unchanged. This is because the values are relative to the previous token, and the space between SHOW and product_title didn't change.This becomes especially confusing when you use certain language features that are parsed out of order. For example, in some ANTLR grammars, comments are not parsed as part of the default channel-they are parsed after everything in the main channel is parsed. Let's add a comment to the first line:", author: "Trevor Harmon", date: Date.new(2023, 9, 11) },
  { title: "Shopify's platform is the Web platform", content: "Remix is now the recommended way to build Admin apps on Shopify. With Remix, you get a best-in-class developer experience while ensuring exceptional out-of-the-box performance for your app. Remix also embraces the web platform and web standards, allowing web developers to use more of their existing knowledge and skills when developing for Shopify. We are reshaping Shopify’s platform to embody the same values, for example by releasing a new, web-centric version of App Bridge.\n\nOne of the powerful ways you can develop for Shopify is by building apps that merchants install to their store. Apps can consist of multiple parts that extend Shopify in different ways, and one core component found  in almost every app is the Admin App: A UI that merchants interact with within the admin area of their store. Here, you can let merchants configure the way your app behaves in their store, visualize data or integrate it with other services outside of Shopify.\n\nHeads-up: The restrictions outlined below apply specifically to cross-origin iframes, where the iframe is on a different origin than the top-level page. This article exclusively talks about cross-origin iframes as all Admin Apps are hosted on a different origin than Shopify Admin.\n\nAdmin apps are, at their core, web apps that Shopify Admin runs in an <iframe>. Iframes are the web’s way of composing multiple web apps together into one, allowing each iframe to take control of a dedicated space of the top-level page. The browser provides a strong isolation between these individual apps (“sandboxing”), so that each app can only influence the space they have been assigned and not interfere with anything else. In a sense, Shopify Admin functions like an operating system where merchants install multiple applications and use them to customize and enhance their workflows.\n\nWithout going into technical details, iframes have been misused in the last few decades as a way to track user behavior on the web. To counteract that, browser vendors have started to restrict what web apps running inside an iframe can and cannot do. As an example, iframes in Safari do not get to set cookies or store data in IndexDB, LocalStorage or SessionStorage. As a result of all these restrictions, some standard practices of web development do not work inside iframes. This can be a source of headaches for developers.\n\nWith postMessage() being the only way to pierce the browser sandbox between page and iframe, we built App Bridge, a message-based protocol. On the one hand, it provides capabilities that can be used to restore functionality that browsers removed in their quest to protect user privacy. On the other hand, it also exposes a set of capabilities and information that allows deep integration of apps with Shopify Admin. The App Bridge protocol is supported by Shopify Admin on the Web and on the mobile app, giving merchants a consistent experience no matter how they prefer to work.", author: "Surma", date: Date.new(2023, 3, 26) },
])
